<template>
  <div class="reuse-container">
  <div class="reuse-list-label">
    <div class="reuse-label">
      <div v-if="authorSelected && !workSelected">
        I verk av
        <span class="author-name">{{ authorSelected?.name }}</span> finner vi
        <span class="author-name">{{ clusterCount }}</span> grupper av likartade stycken.
      </div>
      <div v-if="workSelected && authorSelected">
        I verket
        <span class="work-title">{{ workTitle }}</span>
        av <span class="author-name">{{ authorSelected?.name }}</span> finner vi
        <span class="work-title"> {{ clusterCount }} </span> grupper av Ã¥terbruk.
      </div>
    </div>
  
    </div>
  </div>
  

  <div class="card-container">
    <div v-for="cluster in clusters" v-bind:key="cluster.id">
      <cluster-card :cluster="cluster"></cluster-card>
    </div>
  </div>
  <div class="pagination">
    <v-pagination
      v-model="page"
      class="pagination-numbers"
      :pages="pages"
      :range-size="5"
      active-color="rgb(200,200,200)"
      @update:modelValue="onPageChange"
    />
  </div>
</template>

<script setup lang="ts">
import VPagination from "@hennge/vue3-pagination";
import "@hennge/vue3-pagination/dist/vue3-pagination.css";
import { ref, watch, computed } from "vue";
import { useRoute } from "vue-router";
import { list, get } from "@/services/diana";
import ClusterCard from "@/components/ClusterCard.vue";
import type { Author, Cluster, Work } from "@/types/litteraturlabbet";

const props = defineProps<{
  author: number;
  work?: number;
}>();

// const store = searchStore();
const route = useRoute();
const authorSelected = ref<Author>();
const workSelected = ref<Work>();
const workTitle = ref<string>("");
const clusters = ref<Array<Cluster>>([]);
const clusterCount = ref<number>(0);
const page = ref(1);
const pages = computed(() => {
  return Math.floor(clusterCount.value / 25) + 1;
});

await fetchData(props.author, props.work);

async function fetchData(author: number, work?: number) {
  if (author) {
    authorSelected.value = await get<Author>(author, "author");
    workSelected.value = undefined;
  }

  if (work) {
    workSelected.value = await get<Work>(work, "work/19th_century");
    workTitle.value = workSelected.value.short_title
      ? workSelected.value.short_title
      : workSelected.value.title;
  }

  if (author) {
    await fetchClusters(page.value, author, work);
  }
}

async function fetchClusters(
  page: number,
  authorID: number | undefined,
  workID: number | undefined
) {
  const params = {
    has_author: authorID,
    work: workID,
    limit: 10,
    offset: 10 * (page - 1),
  };

  const clusterResults = await list<Cluster>("cluster", params, 2);
  
  clusterResults.results.forEach((cluster) => {
    let seenSegmentIds = new Set();
    for (let i = 0; i < cluster.segments.length; i++) {
      const segment_i = cluster.segments[i];
      const gid = segment_i.gid;
      if (seenSegmentIds.has(gid)) {
        cluster.segments.splice(i, 1);
        i--;
      } else {
        seenSegmentIds.add(gid);
      }
    }
    cluster.size = cluster.segments.length;
  });
  clusterResults.results.sort((a, b) => b.size - a.size);
  clusters.value = clusterResults.results;
  clusterCount.value = clusterResults.count;
}

async function onPageChange() {
  await fetchClusters(
    page.value,
    authorSelected.value?.id,
    workSelected.value?.id
  );
}

watch(
  () => props.author,
  async (newAuthor, oldAuthor) => {
    await fetchData(props.author, props.work);
  },
  {
    immediate: true,
    deep: true,
  }
);

watch(
  () => props.work,
  async (newWork, oldWork) => {
    await fetchData(props.author, props.work);
  },
  {
    immediate: true,
    deep: true,
  }
);


// watch(
//   [props.author, props.work],
//   async ([newAuthor, oldAuthor], [newWork, oldWork]) => {
//     console.log(newAuthor, oldAuthor, newWork, oldWork);
//     await fetchData(props.author, props.work);
//   },
//   {
//     immediate: true,
//     deep: true,
//   }
// );

// watch(
//   [props.author, props.work],
//   async ([newAuthor, oldAuthor], [newWork, oldWork]) => {
//     console.log(newAuthor, oldAuthor, newWork, oldWork);
//     await fetchData(props.author, props.work);
//   },
//   {
//     immediate: true,
//     deep: true,
//   }
// );
</script>

<style scoped>
.card-container {
  height: 100%;
}

.reuse-container {
  width:100%!important;
}

.reuse-list-label { 
  pointer-events:none;
  margin-bottom: 1rem;
  color: black;
  padding: 1rem;
  padding-top:1rem;
  border-radius: 0px;
}

.reuse-label {
  pointer-events:none;
  position:relative;
  line-height: 2.5rem;
  font-size: 19px;
  text-align:center;
  width:auto;
  line-height:1.5 !important;
}

.pagination {
  margin-top:20px;
  margin-bottom: 1rem;
  width:100%;
}

.pagination-numbers {
  display:flex;
  flex-direction:row;
 justify-content:center;
  width:100%;
}

  @media screen and (max-width: 950px) {
    .reuse-label {
  line-height: 2.5rem;
  font-size: 21px;  

}
.reuse-list-label {
  height: 100%;
  margin-bottom:30px;
}
.pagination {
  margin-right:30px;
  margin-top:20px;
}
  }

</style>
